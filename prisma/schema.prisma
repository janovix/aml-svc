// Prisma schema for AML Core KYC domain
// Learn more about it in the docs: https://pris.ly/d/prisma-schema

generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "sqlite"
  url      = env("DATABASE_URL")
}

enum PersonType {
  PHYSICAL
  MORAL
  TRUST
}

enum DocumentType {
  PASSPORT
  NATIONAL_ID
  DRIVERS_LICENSE
  TAX_ID
  PROOF_OF_ADDRESS
  OTHER
}

enum DocumentStatus {
  PENDING
  VERIFIED
  REJECTED
  EXPIRED
}

enum AddressType {
  RESIDENTIAL
  BUSINESS
  MAILING
  OTHER
}

enum TransactionOperationType {
  PURCHASE
  SALE
}

enum TransactionVehicleType {
  LAND
  MARINE
  AIR
}

model Client {
  rfc               String     @id
  personType        PersonType
  firstName         String?
  lastName          String?
  secondLastName    String?
  birthDate         DateTime?
  curp              String?
  businessName      String?
  incorporationDate DateTime?
  nationality       String?
  email             String
  phone             String
  country           String
  stateCode         String
  city              String
  municipality      String
  neighborhood      String
  street            String
  externalNumber    String
  internalNumber    String?
  postalCode        String
  reference         String?
  notes             String?
  createdAt         DateTime   @default(now())
  updatedAt         DateTime   @updatedAt
  deletedAt         DateTime?

  documents ClientDocument[]
  addresses ClientAddress[]
  transactions Transaction[]
  alerts Alert[]

  @@map("clients")
  @@index([personType])
  @@index([deletedAt])
}

model ClientDocument {
  id             String         @id @default(uuid())
  clientId       String
  documentType   DocumentType
  documentNumber String
  issuingCountry String?
  issueDate      DateTime?
  expiryDate     DateTime?
  status         DocumentStatus @default(PENDING)
  fileUrl        String?
  metadata       String?
  createdAt      DateTime       @default(now())
  updatedAt      DateTime       @updatedAt

  client Client @relation(fields: [clientId], references: [rfc], onDelete: Cascade)

  @@map("client_documents")
  @@index([clientId])
  @@index([documentType])
  @@index([status])
  @@index([expiryDate])
}

model ClientAddress {
  id          String      @id @default(uuid())
  clientId    String
  addressType AddressType @default(RESIDENTIAL)
  street1     String
  street2     String?
  city        String
  state       String?
  postalCode  String?
  country     String
  isPrimary   Boolean     @default(false)
  verifiedAt  DateTime?
  reference   String?
  createdAt   DateTime    @default(now())
  updatedAt   DateTime    @updatedAt

  client Client @relation(fields: [clientId], references: [rfc], onDelete: Cascade)

  @@map("client_addresses")
  @@index([clientId])
  @@index([addressType])
  @@index([country])
}

model Catalog {
  id        String        @id @default(uuid())
  key       String        @unique
  name      String
  active    Boolean       @default(true)
  createdAt DateTime      @default(now())
  updatedAt DateTime      @updatedAt

  items CatalogItem[]

  @@map("catalogs")
  @@index([active])
}

model CatalogItem {
  id             String   @id @default(uuid())
  catalogId      String
  name           String
  normalizedName String
  active         Boolean  @default(true)
  metadata       String?
  createdAt      DateTime @default(now())
  updatedAt      DateTime @updatedAt

  catalog Catalog @relation(fields: [catalogId], references: [id], onDelete: Cascade)

  @@map("catalog_items")
  @@index([catalogId])
  @@index([normalizedName])
  @@index([active])
}

model Transaction {
  id                String                     @id @default(uuid())
  clientId          String
  operationDate     DateTime
  operationType     TransactionOperationType
  branchPostalCode  String
  vehicleType       TransactionVehicleType
  brandId           String
  model             String
  year              Int
  armorLevel        String?
  engineNumber      String?
  plates            String?
  registrationNumber String?
  flagCountryId     String?
  amount            Decimal
  currency          String
  createdAt         DateTime                   @default(now())
  updatedAt         DateTime                   @updatedAt
  deletedAt         DateTime?

  client Client @relation(fields: [clientId], references: [rfc], onDelete: Cascade)
  paymentMethods    TransactionPaymentMethod[]

  @@map("transactions")
  @@index([clientId])
  @@index([operationDate])
  @@index([operationType])
  @@index([vehicleType])
}

model TransactionPaymentMethod {
  id            String      @id @default(uuid())
  transactionId String
  method        String
  amount        Decimal
  createdAt     DateTime    @default(now())
  updatedAt     DateTime    @updatedAt

  transaction Transaction @relation(fields: [transactionId], references: [id], onDelete: Cascade)

  @@map("transaction_payment_methods")
  @@index([transactionId])
}

enum AlertStatus {
  PENDING
  REVIEWED
  RESOLVED
  DISMISSED
}

enum AlertSeverity {
  LOW
  MEDIUM
  HIGH
  CRITICAL
}

model AlertRule {
  id          String   @id @default(uuid())
  name        String
  description String?
  active      Boolean  @default(true)
  severity    AlertSeverity @default(MEDIUM)
  // Dynamic rule configuration stored as JSON
  // Example: { "conditions": [...], "aggregations": {...}, "thresholds": {...} }
  ruleConfig  String   // JSON string containing the dynamic rule configuration
  metadata    String?  // Additional metadata as JSON
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt

  alerts Alert[]

  @@map("alert_rules")
  @@index([active])
  @@index([severity])
}

model Alert {
  id                String      @id @default(uuid())
  alertRuleId       String
  clientId          String
  status            AlertStatus @default(PENDING)
  severity          AlertSeverity
  // Idempotency key: hash of (clientId + alertRuleId + contextHash)
  // This ensures we never create duplicate alerts for the same condition
  idempotencyKey    String      @unique
  // Context hash: hash of the specific data that triggered this alert
  // Example: hash of transaction IDs, amounts, dates, etc.
  contextHash       String
  // Alert details stored as JSON (transaction IDs, amounts, dates, etc.)
  alertData         String      // JSON string with alert-specific data
  // Optional reference to the transaction that triggered the alert
  triggerTransactionId String?
  notes             String?
  reviewedAt        DateTime?
  reviewedBy        String?
  resolvedAt        DateTime?
  resolvedBy        String?
  createdAt         DateTime    @default(now())
  updatedAt         DateTime    @updatedAt

  alertRule AlertRule @relation(fields: [alertRuleId], references: [id], onDelete: Restrict)
  client    Client    @relation(fields: [clientId], references: [rfc], onDelete: Cascade)

  @@map("alerts")
  @@index([alertRuleId])
  @@index([clientId])
  @@index([status])
  @@index([severity])
  @@index([createdAt])
  @@index([idempotencyKey])
}
